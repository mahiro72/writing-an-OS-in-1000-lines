
LLVM
- プログラミング言語(C++,Cなど) から中間表現であるLLVM IRにコンパイルするコンパイラ。中間表現は各CPUアーキテクチャのバイナリに変換することができ、各言語はLLVMへの変換のみを意識するだけで良くなった。

- qemu
  - コンピュータのエミュレータ
    - 異なるCPUアーキテクチャのシステムを模倣できるソフトウェア。VirtualBoxやVMwareに近く、コンテナとは別物
    - 自作OSはハードウェアの初期化やブートローダーの処理が必要でホストOS(mac)上で直接実行できない。QEMUといったハードウェアそのものを模倣するエミュレータを使うことで安全にホストOS上で実行できる。

自作OSの流れ
- LLVMでOSのコードをコンパイル
  - コンパイルの手順は C++,Cといった言語(フロントエンド) から、LLVM IRという中間表現(ミドルエンド)に変換し、特定のCPUアーキテクチャのバイナリに変換する
- QEMUでコンパイルされたバイナリを実行し、動作確認とデバッグ


- RISC-V
  - OSSのCPUアーキテクチャ
  - 他で有名なのはx86やARMなど
  - アセンブリ入門
    - レジスタとは
      - CPUの中にある高速な記憶領域。メモリよりもずっと高速
        - ただし数が限られておりRISC-Vの場合は32個 (RV32,RV64どちらも32個。アーキテクチャの設計として32になっている)
          - RV32は各レジスタが32ビット, RV64は64ビット
      - 計算途中結果や頻繁に使うデータを保持する。たとえば戻り値アドレスやスタックポインタなど
    - スタックの仕組み
      - メモリ上の一時的なデータ保存領域
        - 関数呼び出し情報や、ローカル変数、レジスタの待避先など

- CPUの動作モード
  - M-mode: OpenSBIが動作するモード (MachineMode)
    - 最高特権レベル。ハードウェアの直接制御。OS自体の初期化など
  - S-mode: カーネルが動作するモード (SupervisorMode)
    - OSカーネルが動作。メモリ管理や割り込み処理。ページングの制御など
  - U-mode: アプリケーションが動作するモード (UserMode)
    - 一般のアプリケーション実行。制限された権限。システムコールでS-modeに切り替えられる
  - 補足
    - 特権レベルの概念は各CPUアーキテクチャで共通だが、具体的な実装は違う

- CSR(Control and Status Register)
  - CPUの動作設定を格納するレジスタ
  - 割り込み有効/無効の制御、タイマー設定なども
  - 具体例: 
    - mstatus: マシンステータス
      - 80006080のような値がレジスタに格納されている
      - これは特定のモードをしめし、他のモードに切り替える際にこの値が変わる。
      - どの値がどのモードと紐づくかはRISC-Vの仕様書を参考されたい
    - mepc: 例外発生時のプログラムカウンタ
    - これらの名前は人間が理解しやすい名前(ニーモニック)で、実際には番号(0x300) が割り当てられている。この番号は固定値で定数のようなもの

- 汎用レジスタ
  - x0(常に0), x1(戻り値アドレス), x2(スタックポインタ)が特別なう用途のレジスタであり、それ以外x3-x31はプログラマが自由に使える汎用レジスタ
  - 正確にはレジスタに関してx0:zero, sx1: ra(return address), x2: sp(stack pointer)などニーモニックがつけられているらしい
- rd
  - 読み出した値を格納する汎用レジスタ


レジスタ


特権命令
- csrr rd, csr
  - CSRの読み出し
  - 疑似コード: rd = csr;
- csrw csr, rs
  - CSRの書き込み
  - 疑似コード: csr = rs;
- csrrw rd, csr, rs
  - CSRの読み出しと書き込みを一度に行う
  - 疑似コード: tmp = csr; csr = rs; rd = tmp;
- sret
  - トラップハンドラからの復帰 (プログラムカウンタ、動作モードの復元など)
- sfence.vma
  - TLB(Translation Lookaside Buffer)のクリア




- 実装する機能
  - マルチタスク
    - プロセスの切り替えを行い、複数のプログラムが同時に動作しているように見せかける機能
  - 例外ハンドラ
    - 実行時エラーなどのCPUがOSの介入を必要とするイベントを処理する機能
  - ページング
    - 各プロセスごとの独立したメモリ空間の実現
  - システムコール
    - アプリケーションからOSの機能を呼び出す機能
  - デバイスドライバ
    - ディスクの読み書きなどハードウェアを操作する機能
  - ファイルシステム
    - ディスク上のファイルを管理する機能
  - コマンドラインシェル
    - 利用者がコマンドを入力してOSの機能を呼び出せる機能

```
├── disk/     - ファイルシステムの中身
├── common.c  - カーネル・ユーザー共通ライブラリ: printf関数やmemset関数など
├── common.h  - カーネル・ユーザー共通ライブラリ: 各種構造体・定数などの定義
├── kernel.c  - カーネル: プロセス管理、システムコール、デバイスドライバ、ファイルシステム
├── kernel.h  - カーネル: 各種構造体・定数などの定義
├── kernel.ld - カーネル: リンカスクリプト (メモリレイアウトの定義)
├── shell.c   - コマンドラインシェル
├── user.c    - ユーザー用ライブラリ: システムコールの呼び出し関数など
├── user.h    - ユーザー用ライブラリ: 各種構造体・定数などの定義
├── user.ld   - ユーザー: リンカスクリプト (メモリレイアウトの定義)
└── run.sh    - ビルドスクリプト
```


SBI(Supervisor Binary Interface)
- カーネルのためのAPI
- ハードウェア(CPU, メモリ, デバイス)を操作するための抽象化層

- 実際には
  - アプリケーション -> OS: システムコール
  - OS -> ファームウェア: SBI呼び出し
  - ファームウェア -> ハードウェア
    - ファームウェアはハードウェアを制御留守ための基本的なソフトウェア


- Cは上から下へコンパイルされるためプロトタイプ宣言(関数のシグネチャのみの宣言)が必要
  - 実装がなくてもコンパイル自体は通るが、リンカがリンクできないとのエラーを出してくれる

- メモリアラインメント
  - データがメモリ上に配置される際の整列規則のこと
  - CPUはメモリを一定の単位でアクセスするため、データの開始アドレスをその単位に合わせ効率的なアクセスを実現する


- 例外処理の流れ
  - CPUがmedelegレジスタを確認し、どの動作モードで例外を発生させるか決定する
    - ここではS-Mode
  - 例外発生時のCPUの状態をCSRに保存
  - stvecレジスタの値をプログラムカウンタにセットし、カーネルの例外処理プログラム(例外ハンドラ)にジャンプする
  - 例外ハンドラはカーネルが好きにつかっていいsscratchレジスタをうまくつかって、汎用レジスタの値(例外発生時の実行状態)を保存し、例外の種類に応じた処理を行う。
  - 例外処理終了後、保存していた実行状態から復元し、sret命令を呼び出して例外発生箇所から実行を再開する

プログラムカウンタ
- 現在実行中の命令のアドレスを保持するレジスタ


sret命令
- supervisor return 命令
- 例外処理から通常の処理に戻るための特別な命令



4KB=4096=0x1000 16進数では4KBは1000

プロセスはアプリケーションのインスタンス。各プロセスが独立の実行コンテキストと仮想のアドレスをもつ


アドレス変換の流れ
VPN1 → table1[VPN1] → PPN(物理ページ番号) を取得
                       ↓
                  page table0を特定（PPNが示す4KBのテーブル）
                       ↓
              table0[VPN0] → 実データページのPPNを取得
                             ↓
                        実データのページ
                             ↓
                      offset分だけ進む → 最終的な物理アドレス


// table1のエントリ構造（32ビット）
31                    10 9    1 0
+----------------------+------+-+
|      PPN(22bit)      |flags |V|  
+----------------------+------+-+


// table0のエントリ構造（32ビット）
31                    10 9    1 0
+----------------------+------+-+
|      PPN(22bit)      |flags |V|
+----------------------+------+-+


virtio
- 仮想マシンとホストOS間の効率的なI/O処理を実現するための、仮想化I/Oフレームワーク
- 具体的には、仮想マシンから共有メモリ経由でホストOSのディスク操作を可能とするフレームワークのイメージ
- 物理デバイスのエミュレートせずホストOSのものを利用することで、オーバヘッドを削減している
- virtioには複数デバイスがある。例えばvirtio-blk(ディスクアクセス)、virtio-net(ネットワーク)などなど。これらはユースケースによって利用されるものが変わる
  - 最小構成は、virtio-blkとvirtio-consoleのみ
- データはQMEUが管理する共有メモリ(ホストOSからも直接参照可能)に存在し、その中のvirtioキューを利用されやりとりされる
  - 通信方式にはMMIO(Memory Mapped I/O) が利用される

MMU
- プロセッサ(CPU) とメインメモリの中間に位置するハードウェアコンポーネント
- 仮想アドレスから物理アドレスへの変換やページング機能を持つ
- MMUはMMIOのようなメモリアドレスを使ってデバイスにアクセスする方式もサポートしており、その例の一つとしてvertIOデバイスへのアクセスが挙げられる

データの流れ
```
[自作OS]
    |--> read()システムコールを実行
    |
[Virtioドライバ]
    |--> MMIOを使って共有メモリにリクエストを書き込む
    |    - どのファイルの
    |    - どの位置から
    |    - どのくらいの長さ読むか、などの情報
    |
[共有メモリ/Virtioキュー]
    |--> MMIOで「新しいリクエストがありますよ」と通知
    |
[QEMU] ---------------------------------------.
    |--> キューからリクエスト内容を読み取って処理    |
    |                                          |
    |    [ホストOS]                             | QEMUが
    |        |--> ファイルシステムにアクセス       | 仲介役として
    |        |    (MacOSならHFS+やAPFSなど)      | 処理を制御
    |        |                                 |
    |    [物理デバイス]                          |
    |        |--> SSDやHDDからデータを読み込み     |
    |                                           |
    |<-- データを受け取る <------------------------'
    |
    |--> 読み込んだデータを共有メモリに書き込む
    |--> 「データの準備できました」と割り込みを発生
    |
[Virtioドライバ]
    |--> 割り込みを検知（例外ハンドラが呼ばれる）
    |--> 共有メモリから結果を読み取る
    |
[自作OS]
    `--> データを受け取って処理完了
```


```
+-----------------------------------------------------------------------+ |
|                               ホストOS                                   |
|                                                                         |
|    +----------------------------------------------------------------+ | |
|    |                              QEMU                                | |
|    |                                                                  | |
|    |    +------------------------+      +-------------------------+   | |
|    |    |      ゲストOS          |      |      VirtIOデバイス       |   | |
|    |    |      (RISC-V)         |      |      (仮想ハードウェア)    |    | |
|    |    |                       |      |                         |    | |
|    |    |   +---------------+   |      |                         |    | |
|    |    |   | VirtIOドライバ |   |      |                         |    | |
|    |    |   | (今回実装中)   |   |  MMIO |                         |    | |
|    |    |   |              |<------------->                      |    | |
|    |    |   | ・初期化処理   |    |      |                         |    | |
|    |    |   | ・読み書き処理 |    |      |                         |    | |
|    |    |   +---------------+   |      |                         |    | |
|    |    |                       |      |                         |    | |
|    |    +------------------------+      +-------------+-----------+   | |
|    |                                                 |                | |
|    |                                                 v                | |
|    |                                            lorem.txt             | |
|    |                                                                  | |
|    +----------------------------------------------------------------+ | |
|                                                                         |
+-----------------------------------------------------------------------+ |
```